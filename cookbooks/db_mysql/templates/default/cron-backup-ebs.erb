#!/bin/env ruby
# Cron backup script for MySQL Manager.
# This script is shared for both master and slave DBs...they will be executed
# differently depending on the instance being a master or a slave at the time.

require 'rubygems'
require 'optparse' 
require 'mysql'

require '/var/spool/ec2/user-data.rb'
require '/var/spool/ec2/meta-data.rb'

#set RS_DISTRO
ENV['RS_DISTRO'] = `lsb_release -is`.chomp.downcase

runfile="<%= @run_file %>"
lockfile="<%= @lock_file %>"
max_lag=<%= @max_lag %>

# Required inputs: (must be substituted before installing this template)
backup_snap_prefix='<%= @node[:db_mysql][:backup][:prefix] %>'
master_db_dnsname='<%= @node[:db_mysql][:dns][:master_name] %>'

def error(message)
  puts "#{message} ... aborting backup"
  #TODO: Send an email to the admin....
  exit(-1)
end

def usage(code=0)
  out = $0.split(' ')[0] + " usage: \n"
  out << "  --if-slave Execute only if this instance is a slave DB at this moment \n"
  out << "  --if-master Execute only if this instance is the master DB at this moment \n"
  out << "  --as-master Execute assuming the instance is the master DB\n"
  out << "  --as-slave Execute assuming the instance is a slave DB\n"
  out << "  -m | --max_snapshots MAXSNAPSHOTS  Maximum number of completed snapshots to keep (i.e., rotation size) \n"
  out << "  -D | --keep_daily KEEPDAILY Number of completed daily snapshots to keep (i.e., rotation size) \n"
  out << "  -W | --keep_weekly  KEEPWEEKLY Number of completed weekly snapshots to keep (i.e., rotation size) \n"
  out << "  -M | --keep_monthly  KEEPMONTHLY Number of completed monthly snapshots to keep (i.e., rotation size) \n"
  out << "  -Y | --keep_yearly  KEEPYEARLY Number of completed yearly snapshots to keep (i.e., rotation size) \n"
  out << "  [ --help ]   "
  puts out
  Kernel.exit( code )
end

######Options handling
#Default options
options = {}

opts = OptionParser.new 
opts.on("--help") { raise "Usage:" } 
opts.on("", "--if-master","Execute only if the instance is the master DB") { options[:mode] = "master" } 
opts.on("", "--if-slave","Execute only if the instance a slave DB") { options[:mode] = "slave" } 
opts.on("", "--as-master","Execute assuming the instance is the master DB") { options[:force_mode] = "master" } 
opts.on("", "--as-slave","Execute assuming the instance is a slave DB") { options[:force_mode] = "slave" } 
opts.on("-m=MAXSNAPSHOTS", "--max-snapshots=MAXSNAPSHOTS","Maximum number of completed snapshots to keep (i.e., rotation size)") {|str| options[:max_snapshots] = str.to_i }
opts.on("-D=KEEPDAILY", "--keep_daily=KEEPDAILY","Number of completed snapshots to keep (i.e., rotation size)") {|str| options[:keep_daily] = str.to_i }
opts.on("-W=KEEPWEEKLY", "--keep_weekly=KEEPWEEKLY","Number of completed snapshots to keep (i.e., rotation size)") {|str| options[:keep_weekly] = str.to_i }
opts.on("-M=KEEPMONTHLY", "--keep_monthly=KEEPMONTHLY","Number of completed snapshots to keep (i.e., rotation size)") {|str| options[:keep_monthly] = str.to_i }
opts.on("-Y=KEEPYARLY", "--keep_yearly=KEEPYARLY","Number of completed snapshots to keep (i.e., rotation size)") {|str| options[:keep_yearly] = str.to_i }

begin
  opts.parse(ARGV) 
rescue Exception => e
  puts e 
  usage(-1) 
end

if ! options[:max_snapshots] || options[:max_snapshots]==0
   puts "Invalid number for max snapshots"
   usage(-1)
end

#we require to know when to execute: master or slave cases
usage(-1) unless options[:mode] || options[:force_mode]

# Forcing a mode, automatically will imply the type of backup
options[:mode] = options[:force_mode] if options[:force_mode]

puts "=========  Starting New Backup ========="
puts Time.now

if ! options[:force_mode]
    # 0- Get the master DB and the local DB IPs
    result = ""
    120.times do
      result = `host #{master_db_dnsname}`
      break if $?.success?
      sleep 1
    end

    master_ip=$1 if result =~ /has address\s+(.+)$/

    if ! defined?(master_ip)
      abort "MasterDB doesn't have an associated DNS entry."
    end

    ifconfig_output=`ifconfig eth0`
    this_ip=$1 if ifconfig_output =~ /inet addr:([^\s]+).+/

    if ! defined?(this_ip)
      abort "Couldn't get the local ip of the instance. Cannot know if we're a master or a slave."
    end
    we_are_a_master = (this_ip == master_ip ? true: false)
else
    we_are_a_master = (options[:force_mode] == "master" ? true: false)
end

# 1- Prepare the backup parameters differently depending on being a slave or a master
cmd_params=""
keep_params = "-D #{options[:keep_daily]} -W #{options[:keep_weekly]} -M #{options[:keep_monthly]} -Y #{options[:keep_yearly]}"
backupfile_date=`date +%Y%m%d%H%M`.strip
if we_are_a_master
  #We're the master...finish right here if we're not required to run in master mode
  exit(0) if options[:mode] != "master"
  puts "This is a Master instance."
  # Master backups add '-master-' and then the date to the original volume name (also make sure we only cleanup amongst the master ones)
  cmd_params = "-s \'-master-#{backupfile_date}\' -n \'#{backup_snap_prefix}\'  -c \'#{backup_snap_prefix}-master\' -m #{options[:max_snapshots]} #{keep_params}"
else
  #We're the slave...finish right here if we're not required to run in slave mode
  exit(0) if options[:mode] != "slave"
  puts "This is not a Master instance...must be a slave."

  #Check to see if the slave is initilized and if the lag time behind the master is too high.
  dbcon = Mysql.new("", "root" )
  slave_status = dbcon.query("SHOW SLAVE STATUS").fetch_hash
  if slave_status.nil? || slave_status["Seconds_Behind_Master"].nil? || slave_status["Seconds_Behind_Master"].strip.to_i > max_lag
    puts "Slave is not replicating correctly!!! Exiting..."
    exit -1
  end

  # Slave backups add '-slave-' and then the date to the original volume name
  cmd_params = "-s \'-slave-#{backupfile_date}\' -n \'#{backup_snap_prefix}\' -c \'#{backup_snap_prefix}-slave\' -m #{options[:max_snapshots]} #{keep_params}"
end
# Execute the backup command
puts "/opt/rightscale/db/ec2_ebs/backupDB.rb #{cmd_params}" 
result = `/opt/rightscale/db/ec2_ebs/backupDB.rb #{cmd_params}`
puts result

if $? != 0
   puts "Backup execution failed"
   exit(-1)
end

puts "Backup executed successfully."
now = Time.now
puts "#{now}"
`echo #{now} > #{runfile}`
